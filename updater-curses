#! /usr/bin/perl -w
use strict;
use Getopt::Std;
use FAI::Updater;
use FAI::Updater::Display::Logfile;
use FAI::Updater::Display::Curses;
use POSIX qw(strftime);
$Getopt::Std::STANDARD_HELP_VERSION=1;

# options
our ($opt_H,$opt_s,$opt_n,$opt_o);

our $VERSION="0.1";

my $netgroup='hand-defined';
my $cui;
my $updater;

sub HELP_MESSAGE {
  my $FH = shift;
  print $FH <<EOF
  
Usage: $0 [options] <netgroup|-H host1,host2,...>
  --help            display this help message
  --version         print version
  -o                ordered mode: don't randomize order of hosts
  -s <number>       number of updates running simultanously
  -n                dryrun mode: use a dummy-script instead of really 
                    contacting the clients
EOF
}

sub updater_cb() {
	unless ($updater->run()) {
		exit(0) unless ($updater->max_simultanous());
	}
}

sub shutdown() {
	$cui->status("shutting down...");
	$updater->max_simultanous(0);
}
# - - - - - - - - - - - - - - - - - - - -
#  main routine
# - - - - - - - - - - - - - - - - - - - -

getopts('hH:s:no');
# emit help message when no hosts/no netgroup is given on the command line
(($#ARGV<0) and ! $opt_H) and HELP_MESSAGE(*STDERR) and exit(1);
$netgroup=$ARGV[0] if $ARGV[0];

#initialize Curses
$cui=new Curses::UI(-color_support=>1, -clear_on_exit=>1);
$cui->set_binding( \&shutdown, "\cQ");

# create logdir
my $logdir="/var/log/fai-updater/".strftime("%Y-%m-%d_%H-%M-%S",localtime);
die "can't create logdir $logdir" unless mkdir $logdir;

my $display=FAI::Updater::Display::Curses->new(CUI=>$cui);
$display->append(FAI::Updater::Display::Logfile->new(FILENAME=>"$logdir/FAI_UPDATER.log"));
$updater=FAI::Updater->new(DISPLAY=>$display,PING=>0,DRYRUN=>$opt_n,ORDERED=>$opt_o,LOGDIR=>$logdir);
$updater->max_simultanous($opt_s) if $opt_s;
$updater->init_hostlist( $opt_H ? split(/,/,$opt_H) : split(/\s/,`libexec/get_hostlist $netgroup`));

$cui->draw();
$cui->set_timer('updater',\&updater_cb);
$cui->mainloop;
